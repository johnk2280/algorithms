# 1. На улице встретились N друзей. Каждый пожал руку всем остальным друзьям (по одному разу).
# Сколько рукопожатий было?

# Примечание. Решите задачу при помощи построения графа.

"""
Так как граф является абстрактной структорой, которою можно описать различными методами,
то из условия задачи не совсем понятно, каким конкретно методом нужно описать граф.

На свое усмотрение для решения данной задачи я выбрал 2 метода:
а) Описание графа через матрицу смежности;
б) Описание графа через список смежности.

Различие между двумя методами заключается не только в самой структуре (список списков против словаря множеств).
но и в методе подсчета.
В первом случае мы будем считать количество рукопожатий (ребер графа) для каждого друга (вершины).
Во втором случае мы будем считать количество друзей (смежных вершин) с кем поздоровался каждый друг.

Формула решения данной задачи: n * (n - 1) / 2
Т.к. каждый друг поздоровался со всеми остальными,
то такой граф можно создать ненаправленным.
Матрица смежности такого графа будет квадратной - n * n.
"""


def matrix_creating(n):

    """
    Функция создания матрицы смежности ненаправленного графа.
    Возвращаемая данной функцией матрица является симметричной относительно диагональной линии,
    идущей от верхнего левого угла к правому нижнему.
    """

    matrix = [[0 if j == i else 1 for j in range(n)] for i in range(n)]
    return matrix


def graph_creating(n):

    """
    Функция создания списка смежности графа.
    Данная функция возвращает словарь множеств начиная с 1.
    Список смежности генерируется по числу вершин (в нашем случае - друзей).
    В качестве ключа принимается номер вершины (друга), в качестве значения - множество смежных вершин (соседей).
    Вместо множества можно использовать список.
    Так как при малом количестве вершин, это не влияет на 'O-большое' (время выполнения алгоритма).
    """

    graph = {i: {j for j in range(1, n + 1) if j != i} for i in range(1, n + 1)}
    return graph


def handshake_counting(obj):
    """
    Функция подсчета рукопожатий каждого друга со всем остальными.
    На вход поступает матрица, либо словарь.
    В функции имеется проверка на список/словарь.
    В зависимости от типа объекта производится подсчет суммы следующи методом:
    а) для словаря (списка смежности) считается количество смежных вершин (соседей);
    б) для матрицы смежности - сумма ребер для каждой вершины.
    """
    total_sum = 0

    if hasattr(obj, '__iter__'):
        if hasattr(obj, 'items'):
            for key in obj.keys():
                total_sum += len(obj[key])
        else:
            for el in obj:
                total_sum += sum(el)

    return total_sum // 2


def test_handshakes_number(a, n):
    """
    Функция для проверки полученного результа с результатом формулы n * (n - 1) / 2.
    Возвращает True или False.
    """
    num = n * (n - 1) // 2
    return a == num


n = int(input('Enter the number of friends: '))

# Вывод на экран самой матрицы и ее проверки.
matrix = matrix_creating(n)
matrix_count = handshake_counting(matrix)
print(*matrix, sep='\n')
print(f'Number of handshakes (matrix): {matrix_count}')
print(f'Test result: {test_handshakes_number(matrix_count, n)}')

print('-' * 30)

# Вывод на экран графа в виде словаря и его проверка.
graph = graph_creating(n)
print(*graph.items(), sep='\n')
graph_count = handshake_counting(graph)
print(f'Number of handshakes (dict): {graph_count}')
print(f'Test result: {test_handshakes_number(graph_count, n)}')




